/*$file${.::sawcontroller.ino} #############################################*/
/*
* Model: SawController.qm
* File:  ${.::sawcontroller.ino}
*
* This code has been generated by QM 4.3.0 (https://www.state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*$endhead${.::sawcontroller.ino} ##########################################*/
#include "qpn.h"     // QP-nano framework
#include "Arduino.h" // Arduino API
#include "targetsteps.h"

//============================================================================
// declare all AO classes...
/*$declare${AOs::Indicator} ################################################*/
/*${AOs::Indicator} ........................................................*/
typedef struct Indicator {
/* protected: */
    QActive super;
} Indicator;

/* protected: */
static QState Indicator_initial(Indicator * const me);
static QState Indicator_RedOnGreenOff(Indicator * const me);
static QState Indicator_RedOnGreenOn(Indicator * const me);
static QState Indicator_RedOffGreenOn(Indicator * const me);
static QState Indicator_RedOffGreenOff(Indicator * const me);
static QState Indicator_RedOffGreenFlash(Indicator * const me);
static QState Indicator_onA(Indicator * const me);
static QState Indicator_offA(Indicator * const me);
static QState Indicator_GreenOffRedFlash(Indicator * const me);
static QState Indicator_offB(Indicator * const me);
static QState Indicator_onB(Indicator * const me);
static QState Indicator_GreenRedFlashSync(Indicator * const me);
static QState Indicator_offC(Indicator * const me);
static QState Indicator_onC(Indicator * const me);
static QState Indicator_GreenRedFlashOutofSync(Indicator * const me);
static QState Indicator_offD(Indicator * const me);
static QState Indicator_onD(Indicator * const me);
/*$enddecl${AOs::Indicator} ################################################*/
/*$declare${AOs::Buttons} ##################################################*/
/*${AOs::Buttons} ..........................................................*/
typedef struct Buttons {
/* protected: */
    QActive super;
} Buttons;

/* protected: */
static QState Buttons_initial(Buttons * const me);
static QState Buttons_wait(Buttons * const me);
static QState Buttons_Afirst(Buttons * const me);
static QState Buttons_Bfirst(Buttons * const me);
/*$enddecl${AOs::Buttons} ##################################################*/
/*$declare${AOs::Stage} ####################################################*/
/*${AOs::Stage} ............................................................*/
typedef struct Stage {
/* protected: */
    QActive super;

/* private: */
    uint32_t CurrentStep;
    uint16_t CurrentCut;
} Stage;

/* protected: */
static QState Stage_initial(Stage * const me);
static QState Stage_ReadyWaiting(Stage * const me);

// drive the stage to the home position, then flash the indicators together
// Stepper speed and direction set on entry
static QState Stage_FindHome(Stage * const me);
static QState Stage_HomeInit(Stage * const me);
static QState Stage_AtHome(Stage * const me);
static QState Stage_CutSequence(Stage * const me);
static QState Stage_SeekSuper(Stage * const me);
static QState Stage_SeekHome(Stage * const me);
static QState Stage_SeekAway(Stage * const me);
static QState Stage_Error(Stage * const me);
static QState Stage_Complete(Stage * const me);
static QState Stage_ClearHome(Stage * const me);
static QState Stage_ShortMove(Stage * const me);
/*$enddecl${AOs::Stage} ####################################################*/

//...

#define SERIALDEBUG

// AO instances and event queue buffers for them...
Indicator AO_Indicator;
static QEvt l_indicatorQSto[40]; // Event queue storage for Indicator
Buttons AO_Buttons;
static QEvt l_buttonsQSto[40]; // Event queue storage for Buttons
Stage AO_Stage;
static QEvt l_stageQSto[40]; // Event queue storage for Buttons

//...

//============================================================================
// QF_active[] array defines all active object control blocks ----------------
QActiveCB const Q_ROM QF_active[] = {
    { (QActive *)0,           (QEvt *)0,         0U                  },
    { (QActive *)&AO_Indicator,  l_indicatorQSto,     Q_DIM(l_indicatorQSto) },
    { (QActive *)&AO_Buttons,    l_buttonsQSto,       Q_DIM(l_buttonsQSto) },
    { (QActive *)&AO_Stage,    l_stageQSto,     Q_DIM(l_stageQSto) }

};

//============================================================================

// various constants for the application...
enum {
    BSP_TICKS_PER_SEC = 10000, // number of system clock ticks in one second
    TicksPerISR = 100, // The switches get checked BSP_TICKS_PER_SEC/TicksPerISR
    BUTTON_PRESS_TOUT = BSP_TICKS_PER_SEC/5, // how close together do button presses need to be
    LED_RED = 13,
    LED_GREEN = 12,
    TBEN_P = 9,    // Pin for enable - high disables
    TBCLK_P = 10,  // Pin for step  - pulse steps
    TBCW_P = 11,   // pin for direction - changing this changes direction
    OPTICAL_A = 2, /* blue wire */
    OPTICAL_B = 3, /* blue and white wire */
    BUTTON_A = 4, /* orange and white wire */
    BUTTON_B = 5  /*  brown wire */
};

enum InputSignals {
// first set to do with indicators
CHANGE_INDICATOR_SIG=Q_USER_SIG,
GO_TO_A_SIG,
GO_TO_B_SIG,
GO_TO_C_SIG,
GO_TO_D_SIG,
GO_TO_E_SIG,
GO_TO_F_SIG,
GO_TO_G_SIG,
// optical sensors
OPTICALSTOP_A_SIG,
OPTICALSTOP_B_SIG,
// buttons - unprocessed
BUTTONPRESS_A_SIG,
BUTTONPRESS_B_SIG,
// buttons - processed
SINGLEPRESS_A_SIG,
SINGLEPRESS_B_SIG,
DOUBLEPRESS_SIG,
DUALPRESS_SIG

};
void BSP_Debug(const char * msg)
{
#ifdef SERIALDEBUG
    Serial.println(msg);
#endif
}

void ButtonASingle()
{
BSP_Debug("single press A");
QACTIVE_POST_ISR((QMActive *)&AO_Stage, SINGLEPRESS_A_SIG, 0U);

}
void ButtonADouble()
{
BSP_Debug("double press A");
}
void ButtonBSingle()
{
BSP_Debug("single press B");
}
void ButtonBDouble()
{
BSP_Debug("double press B");
}
void ButtonAB()
{
BSP_Debug("simultaneous press AB");
QACTIVE_POST_ISR((QMActive *)&AO_Stage, DUALPRESS_SIG, 0U);
}


// Setting indicator
void LightsOff() {
QACTIVE_POST_ISR((QMActive *)&AO_Indicator, CHANGE_INDICATOR_SIG, 0U);
}

void RedOffGreenOn() {
LightsOff();
QACTIVE_POST_ISR((QMActive *)&AO_Indicator, GO_TO_A_SIG, 0U);
}

void RedOnGreenOff() {
LightsOff();
QACTIVE_POST_ISR((QMActive *)&AO_Indicator, GO_TO_B_SIG, 0U);
}

void RedOnGreenOn() {
LightsOff();
QACTIVE_POST_ISR((QMActive *)&AO_Indicator, GO_TO_C_SIG, 0U);
}

void RedOffGreenFlash() {
LightsOff();
QACTIVE_POST_ISR((QMActive *)&AO_Indicator, GO_TO_D_SIG, 0U);
}

void RedFlashGreenOff() {
LightsOff();
QACTIVE_POST_ISR((QMActive *)&AO_Indicator, GO_TO_E_SIG, 0U);
}

void RedFlashGreenFlashSync() {
LightsOff();
QACTIVE_POST_ISR((QMActive *)&AO_Indicator, GO_TO_F_SIG, 0U);
}

void RedFlashGreenFlashASync() {
LightsOff();
QACTIVE_POST_ISR((QMActive *)&AO_Indicator, GO_TO_G_SIG, 0U);
}

void setDirectionHome(){
  digitalWrite(TBCW_P, HIGH);
}

void setDirectionAway(){
    digitalWrite(TBCW_P, LOW);
}

void activateStepper(){
   digitalWrite(TBEN_P, LOW);
}

void deactivateStepper(){
   digitalWrite(TBEN_P, HIGH);
}

void setStepperSeed(QActive * who, QTimeEvtCtr Tm) {
   QActive_armX(who, 0U, Tm, Tm);
}
void stopStepperSpeedTimer(QActive * who) {
   QActive_disarmX(who, 0U);
}

void doStep(){
    digitalWrite(TBCLK_P, HIGH);
    digitalWrite(TBCLK_P, LOW);
}
// Document the indicator states
// Started and waiting - red and green on - this is where it stops before attempting to find the home position.
// Press a button to seek home
// At home - red and green flashing together

// Button object is sending events to the stage object. stage object sends events to the indicators
// Button events are sent from the procedures above
//............................................................................
void setup() {
    // initialize the QF-nano framework
    QF_init(Q_DIM(QF_active));

    // initialize all AOs...
    QActive_ctor(&AO_Indicator.super, Q_STATE_CAST(&Indicator_initial));
    QActive_ctor(&AO_Buttons.super, Q_STATE_CAST(&Buttons_initial));
    QActive_ctor(&AO_Stage.super, Q_STATE_CAST(&Stage_initial));

    // initialize the hardware used in this sketch...
    pinMode(LED_RED, OUTPUT); // set the LED-L pin to output
    pinMode(LED_GREEN, OUTPUT);
    digitalWrite(LED_GREEN, LOW);
    digitalWrite(LED_RED, LOW);

    //button pins
    pinMode(BUTTON_A, INPUT);
    pinMode(BUTTON_B, INPUT);

    // motor control pins
    pinMode(TBEN_P, OUTPUT);
    pinMode(TBCLK_P, OUTPUT);
    pinMode(TBCW_P, OUTPUT);

#ifdef SERIALDEBUG
    Serial.begin(115200);   // set the highest stanard baud rate of 115200 bps
    Serial.print(F("Start, QP-nano: "));
    Serial.print(F(QP_VERSION_STR));
    Serial.println("");
    Serial.print("CPU Clock frequency ");
    Serial.println(F_CPU);
#endif
}

//............................................................................
void loop() {
    QF_run(); // run the QF-nano framework
}

//============================================================================
// interrupts...
ISR(TIMER2_COMPA_vect) {
    QF_tickXISR(0); // process time events for tick rate 0

     // No need to clear the interrupt source since the Timer2 compare
    // interrupt is automatically cleared in hardware when the ISR runs.

    // optical home needs to fire on a low->high transition
    // advance could be on either transition.
    // both need to be on transition, otherwise we flood the event queues
    // Might be best to have another, slower ISR for buttons, or only check them every 10th
    // entry to this loop

    static uint8_t interruptCounter = 0;
    // need to sort this out - probably want to arrange for firing on button release
    static uint8_t nOld=0;   /* previous-previous switch bitmask */
    static uint8_t nPrev=0;  /* previous  switch bitmask */
    static uint8_t nOutput=0; /* debounced switch bitmaks */
    static uint8_t pOutput=0;
    ++interruptCounter;
    if (interruptCounter == TicksPerISR) {
       // only check the switches every 10 clock ticks
       interruptCounter = 0;
       // do the low frequency stuff, like button checks

       // read AND debounce all the switches
       /* read the current state of the switches, ignoring
        the serial port pins. all the inputs need to be on
        PORTD (pins 0 to 7) */
        // B00111100 needs to match the input pins defined at the top. i.e we
        // want 2,3,4,5. Leave 0 and 1 alone - they are for serial IO.
        uint8_t nCurrent = PIND & B00111100;
        nOutput = (nOutput & (nOld | nPrev | nCurrent)) |
                             (nOld & nPrev & nCurrent);
        nOld = nPrev;
        nPrev = nCurrent;


        // compare  nOutput and pOutput to get a transition
        // low to high transitions only
        uint8_t LowtoHigh = nOutput & (~pOutput);
        /* the following relies on the input ports being PIN numbers 0-7 */
        uint8_t opticalA = LowtoHigh & (1 << OPTICAL_A);
        uint8_t opticalB = LowtoHigh & (1 << OPTICAL_B);
        uint8_t buttonA = LowtoHigh & (1 << BUTTON_A);
        uint8_t buttonB = LowtoHigh & (1 << BUTTON_B);
        pOutput=nOutput;

        if (opticalA) {
           BSP_Debug("Optical A");
           QACTIVE_POST_ISR((QMActive *)&AO_Stage, OPTICALSTOP_A_SIG, 0U);
        }
        if (opticalB) {
           BSP_Debug("Optical B");
           QACTIVE_POST_ISR((QMActive *)&AO_Stage, OPTICALSTOP_B_SIG, 0U);
        }

        if (buttonA) {
            //BSP_Debug("Button A");
            QACTIVE_POST_ISR((QMActive *)&AO_Buttons, BUTTONPRESS_A_SIG, 0U);
        }

        if (buttonB) {
            //BSP_Debug("Button B");
            QACTIVE_POST_ISR((QMActive *)&AO_Buttons, BUTTONPRESS_B_SIG, 0U);
        }

   }




}

//============================================================================
// QF callbacks...
void QF_onStartup(void) {
    // set Timer2 in CTC mode, 1/1024 prescaler, start the timer ticking...
    TCCR2A = (1U << WGM21) | (0U << WGM20);
//    TCCR2B = (1U << CS22 ) | (1U << CS21) | (1U << CS20); // 1/2^10
//    TCCR2B = (1U << CS22 ) | (1U << CS21) | (0U << CS20); // 1/256
//    TCCR2B = (1U << CS22 ) | (0U << CS21) | (1U << CS20); // 1/128
    TCCR2B = (1U << CS22 ) | (0U << CS21) | (0U << CS20); // 1/64

    ASSR  &= ~(1U << AS2);
    TIMSK2 = (1U << OCIE2A); // enable TIMER2 compare Interrupt
    TCNT2  = 0U;

    // set the output-compare register based on the desired tick frequency
    //    OCR2A  = (F_CPU / 1024U / BSP_TICKS_PER_SEC) - 1U;
    OCR2A  = (F_CPU  / 64 / BSP_TICKS_PER_SEC ) - 1U;

}
//............................................................................
void QV_onIdle(void) {   // called with interrupts DISABLED
    // Put the CPU and peripherals to the low-power mode. You might
    // need to customize the clock management for your application,
    // see the datasheet for your particular AVR MCU.
    SMCR = (0 << SM0) | (1 << SE); // idle mode, adjust to your project
    QV_CPU_SLEEP();  // atomically go to sleep and enable interrupts
}
//............................................................................
void Q_onAssert(char const Q_ROM * const file, int line) {
    // implement the error-handling policy for your application!!!
    QF_INT_DISABLE(); // disable all interrupts
    QF_RESET();  // reset the CPU
}

//============================================================================
// define all AO classes (state machine)...
/* Check for the minimum required QP version */
#if (QP_VERSION < 630U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpn version 6.3.0 or higher required
#endif

/*$define${AOs::Indicator} #################################################*/
/*${AOs::Indicator} ........................................................*/
/*${AOs::Indicator::SM} ....................................................*/
static QState Indicator_initial(Indicator * const me) {
    /*${AOs::Indicator::SM::initial} */
    return Q_TRAN(&Indicator_RedOffGreenOff);
}
/*${AOs::Indicator::SM::RedOnGreenOff} .....................................*/
static QState Indicator_RedOnGreenOff(Indicator * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Indicator::SM::RedOnGreenOff} */
        case Q_ENTRY_SIG: {
                // Turn on the LEDs
                digitalWrite(LED_GREEN, LOW);
                digitalWrite(LED_RED, HIGH);

            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Indicator::SM::RedOnGreenOff::CHANGE_INDICATOR} */
        case CHANGE_INDICATOR_SIG: {
            status_ = Q_TRAN(&Indicator_RedOffGreenOff);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Indicator::SM::RedOnGreenOn} ......................................*/
static QState Indicator_RedOnGreenOn(Indicator * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Indicator::SM::RedOnGreenOn} */
        case Q_ENTRY_SIG: {
                // Turn on the LEDs
                digitalWrite(LED_GREEN, HIGH);
                digitalWrite(LED_RED, HIGH);

            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Indicator::SM::RedOnGreenOn::CHANGE_INDICATOR} */
        case CHANGE_INDICATOR_SIG: {
            status_ = Q_TRAN(&Indicator_RedOffGreenOff);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Indicator::SM::RedOffGreenOn} .....................................*/
static QState Indicator_RedOffGreenOn(Indicator * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Indicator::SM::RedOffGreenOn} */
        case Q_ENTRY_SIG: {
                // Turn on the LEDs
                digitalWrite(LED_GREEN, HIGH);
                digitalWrite(LED_RED, LOW);


            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Indicator::SM::RedOffGreenOn::CHANGE_INDICATOR} */
        case CHANGE_INDICATOR_SIG: {
            status_ = Q_TRAN(&Indicator_RedOffGreenOff);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Indicator::SM::RedOffGreenOff} ....................................*/
static QState Indicator_RedOffGreenOff(Indicator * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Indicator::SM::RedOffGreenOff} */
        case Q_ENTRY_SIG: {
                digitalWrite(LED_GREEN, LOW);
                digitalWrite(LED_RED, LOW);

            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Indicator::SM::RedOffGreenOff::GO_TO_A} */
        case GO_TO_A_SIG: {
            status_ = Q_TRAN(&Indicator_RedOffGreenOn);
            break;
        }
        /*${AOs::Indicator::SM::RedOffGreenOff::GO_TO_B} */
        case GO_TO_B_SIG: {
            status_ = Q_TRAN(&Indicator_RedOnGreenOff);
            break;
        }
        /*${AOs::Indicator::SM::RedOffGreenOff::GO_TO_C} */
        case GO_TO_C_SIG: {
            status_ = Q_TRAN(&Indicator_RedOnGreenOn);
            break;
        }
        /*${AOs::Indicator::SM::RedOffGreenOff::GO_TO_D} */
        case GO_TO_D_SIG: {
            status_ = Q_TRAN(&Indicator_RedOffGreenFlash);
            break;
        }
        /*${AOs::Indicator::SM::RedOffGreenOff::GO_TO_E} */
        case GO_TO_E_SIG: {
            status_ = Q_TRAN(&Indicator_GreenOffRedFlash);
            break;
        }
        /*${AOs::Indicator::SM::RedOffGreenOff::GO_TO_F} */
        case GO_TO_F_SIG: {
            status_ = Q_TRAN(&Indicator_GreenRedFlashSync);
            break;
        }
        /*${AOs::Indicator::SM::RedOffGreenOff::GO_TO_G} */
        case GO_TO_G_SIG: {
            status_ = Q_TRAN(&Indicator_GreenRedFlashOutofSync);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Indicator::SM::RedOffGreenFlash} ..................................*/
static QState Indicator_RedOffGreenFlash(Indicator * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Indicator::SM::RedOffGreenFlash} */
        case Q_ENTRY_SIG: {
            digitalWrite(LED_RED, LOW);
            QActive_armX(&me->super, 0U,
                         BSP_TICKS_PER_SEC/2U, BSP_TICKS_PER_SEC/2U);


            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Indicator::SM::RedOffGreenFlash} */
        case Q_EXIT_SIG: {
            QActive_disarmX(&me->super, 0U);

            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Indicator::SM::RedOffGreenFlash::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Indicator_onA);
            break;
        }
        /*${AOs::Indicator::SM::RedOffGreenFlash::CHANGE_INDICATOR} */
        case CHANGE_INDICATOR_SIG: {
            status_ = Q_TRAN(&Indicator_RedOffGreenOff);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Indicator::SM::RedOffGreenFlash::onA} .............................*/
static QState Indicator_onA(Indicator * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Indicator::SM::RedOffGreenFlash::onA} */
        case Q_ENTRY_SIG: {
            digitalWrite(LED_GREEN, HIGH);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Indicator::SM::RedOffGreenFlash::onA::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&Indicator_offA);
            break;
        }
        default: {
            status_ = Q_SUPER(&Indicator_RedOffGreenFlash);
            break;
        }
    }
    return status_;
}
/*${AOs::Indicator::SM::RedOffGreenFlash::offA} ............................*/
static QState Indicator_offA(Indicator * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Indicator::SM::RedOffGreenFlash::offA} */
        case Q_ENTRY_SIG: {
            digitalWrite(LED_GREEN, LOW);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Indicator::SM::RedOffGreenFlash::offA::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&Indicator_onA);
            break;
        }
        default: {
            status_ = Q_SUPER(&Indicator_RedOffGreenFlash);
            break;
        }
    }
    return status_;
}
/*${AOs::Indicator::SM::GreenOffRedFlash} ..................................*/
static QState Indicator_GreenOffRedFlash(Indicator * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Indicator::SM::GreenOffRedFlash} */
        case Q_ENTRY_SIG: {
            digitalWrite(LED_GREEN, LOW);
            QActive_armX(&me->super, 0U,
                         BSP_TICKS_PER_SEC/2U, BSP_TICKS_PER_SEC/2U);


            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Indicator::SM::GreenOffRedFlash} */
        case Q_EXIT_SIG: {
            QActive_disarmX(&me->super, 0U);

            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Indicator::SM::GreenOffRedFlash::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Indicator_onB);
            break;
        }
        /*${AOs::Indicator::SM::GreenOffRedFlash::CHANGE_INDICATOR} */
        case CHANGE_INDICATOR_SIG: {
            status_ = Q_TRAN(&Indicator_RedOffGreenOff);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Indicator::SM::GreenOffRedFlash::offB} ............................*/
static QState Indicator_offB(Indicator * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Indicator::SM::GreenOffRedFlash::offB} */
        case Q_ENTRY_SIG: {
            digitalWrite(LED_RED, LOW);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Indicator::SM::GreenOffRedFlash::offB::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&Indicator_onB);
            break;
        }
        default: {
            status_ = Q_SUPER(&Indicator_GreenOffRedFlash);
            break;
        }
    }
    return status_;
}
/*${AOs::Indicator::SM::GreenOffRedFlash::onB} .............................*/
static QState Indicator_onB(Indicator * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Indicator::SM::GreenOffRedFlash::onB} */
        case Q_ENTRY_SIG: {
            digitalWrite(LED_RED, HIGH);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Indicator::SM::GreenOffRedFlash::onB::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&Indicator_offB);
            break;
        }
        default: {
            status_ = Q_SUPER(&Indicator_GreenOffRedFlash);
            break;
        }
    }
    return status_;
}
/*${AOs::Indicator::SM::GreenRedFlashSync} .................................*/
static QState Indicator_GreenRedFlashSync(Indicator * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Indicator::SM::GreenRedFlashSync} */
        case Q_ENTRY_SIG: {
            QActive_armX(&me->super, 0U,
                             BSP_TICKS_PER_SEC/2U, BSP_TICKS_PER_SEC/2U);


            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Indicator::SM::GreenRedFlashSync} */
        case Q_EXIT_SIG: {
            QActive_disarmX(&me->super, 0U);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Indicator::SM::GreenRedFlashSyn~::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Indicator_onC);
            break;
        }
        /*${AOs::Indicator::SM::GreenRedFlashSyn~::CHANGE_INDICATOR} */
        case CHANGE_INDICATOR_SIG: {
            status_ = Q_TRAN(&Indicator_RedOffGreenOff);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Indicator::SM::GreenRedFlashSyn~::offC} ...........................*/
static QState Indicator_offC(Indicator * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Indicator::SM::GreenRedFlashSyn~::offC} */
        case Q_ENTRY_SIG: {
            digitalWrite(LED_RED, LOW);
            digitalWrite(LED_GREEN, LOW);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Indicator::SM::GreenRedFlashSyn~::offC::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&Indicator_onC);
            break;
        }
        default: {
            status_ = Q_SUPER(&Indicator_GreenRedFlashSync);
            break;
        }
    }
    return status_;
}
/*${AOs::Indicator::SM::GreenRedFlashSyn~::onC} ............................*/
static QState Indicator_onC(Indicator * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Indicator::SM::GreenRedFlashSyn~::onC} */
        case Q_ENTRY_SIG: {
            digitalWrite(LED_RED, HIGH);
            digitalWrite(LED_GREEN, HIGH);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Indicator::SM::GreenRedFlashSyn~::onC::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&Indicator_offC);
            break;
        }
        default: {
            status_ = Q_SUPER(&Indicator_GreenRedFlashSync);
            break;
        }
    }
    return status_;
}
/*${AOs::Indicator::SM::GreenRedFlashOutofSync} ............................*/
static QState Indicator_GreenRedFlashOutofSync(Indicator * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Indicator::SM::GreenRedFlashOutofSync} */
        case Q_ENTRY_SIG: {
            QActive_armX(&me->super, 0U,
                         BSP_TICKS_PER_SEC/2U, BSP_TICKS_PER_SEC/2U);


            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Indicator::SM::GreenRedFlashOutofSync} */
        case Q_EXIT_SIG: {
            QActive_disarmX(&me->super, 0U);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Indicator::SM::GreenRedFlashOut~::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Indicator_onD);
            break;
        }
        /*${AOs::Indicator::SM::GreenRedFlashOut~::CHANGE_INDICATOR} */
        case CHANGE_INDICATOR_SIG: {
            status_ = Q_TRAN(&Indicator_RedOffGreenOff);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Indicator::SM::GreenRedFlashOut~::offD} ...........................*/
static QState Indicator_offD(Indicator * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Indicator::SM::GreenRedFlashOut~::offD} */
        case Q_ENTRY_SIG: {
            digitalWrite(LED_RED, LOW);
            digitalWrite(LED_GREEN, HIGH);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Indicator::SM::GreenRedFlashOut~::offD::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&Indicator_onD);
            break;
        }
        default: {
            status_ = Q_SUPER(&Indicator_GreenRedFlashOutofSync);
            break;
        }
    }
    return status_;
}
/*${AOs::Indicator::SM::GreenRedFlashOut~::onD} ............................*/
static QState Indicator_onD(Indicator * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Indicator::SM::GreenRedFlashOut~::onD} */
        case Q_ENTRY_SIG: {
            digitalWrite(LED_RED, HIGH);
            digitalWrite(LED_GREEN, LOW);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Indicator::SM::GreenRedFlashOut~::onD::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&Indicator_offD);
            break;
        }
        default: {
            status_ = Q_SUPER(&Indicator_GreenRedFlashOutofSync);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::Indicator} #################################################*/
/*$define${AOs::Buttons} ###################################################*/
/*${AOs::Buttons} ..........................................................*/
/*${AOs::Buttons::SM} ......................................................*/
static QState Buttons_initial(Buttons * const me) {
    /*${AOs::Buttons::SM::initial} */
    return Q_TRAN(&Buttons_wait);
}
/*${AOs::Buttons::SM::wait} ................................................*/
static QState Buttons_wait(Buttons * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Buttons::SM::wait::BUTTONPRESS_A} */
        case BUTTONPRESS_A_SIG: {
            status_ = Q_TRAN(&Buttons_Afirst);
            break;
        }
        /*${AOs::Buttons::SM::wait::BUTTONPRESS_B} */
        case BUTTONPRESS_B_SIG: {
            status_ = Q_TRAN(&Buttons_Bfirst);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Buttons::SM::wait::Afirst} ........................................*/
static QState Buttons_Afirst(Buttons * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Buttons::SM::wait::Afirst} */
        case Q_ENTRY_SIG: {
            QActive_armX(&me->super, 0U, BUTTON_PRESS_TOUT, 0U);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Buttons::SM::wait::Afirst} */
        case Q_EXIT_SIG: {
            QActive_disarmX(&me->super, 0U);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Buttons::SM::wait::Afirst::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            // send single press
            ButtonASingle();
            status_ = Q_TRAN(&Buttons_wait);
            break;
        }
        /*${AOs::Buttons::SM::wait::Afirst::BUTTONPRESS_A} */
        case BUTTONPRESS_A_SIG: {
            // send double press
            ButtonADouble();
            status_ = Q_TRAN(&Buttons_wait);
            break;
        }
        /*${AOs::Buttons::SM::wait::Afirst::BUTTONPRESS_B} */
        case BUTTONPRESS_B_SIG: {
            // send dual press
            ButtonAB();
            status_ = Q_TRAN(&Buttons_wait);
            break;
        }
        default: {
            status_ = Q_SUPER(&Buttons_wait);
            break;
        }
    }
    return status_;
}
/*${AOs::Buttons::SM::wait::Bfirst} ........................................*/
static QState Buttons_Bfirst(Buttons * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Buttons::SM::wait::Bfirst} */
        case Q_ENTRY_SIG: {
            QActive_armX(&me->super, 0U, BUTTON_PRESS_TOUT, 0U);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Buttons::SM::wait::Bfirst} */
        case Q_EXIT_SIG: {
            QActive_disarmX(&me->super, 0U);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Buttons::SM::wait::Bfirst::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            // send single press B
            ButtonBSingle();

            status_ = Q_TRAN(&Buttons_wait);
            break;
        }
        /*${AOs::Buttons::SM::wait::Bfirst::BUTTONPRESS_B} */
        case BUTTONPRESS_B_SIG: {
            // send double press B
            ButtonBDouble();
            status_ = Q_TRAN(&Buttons_wait);
            break;
        }
        /*${AOs::Buttons::SM::wait::Bfirst::BUTTONPRESS_A} */
        case BUTTONPRESS_A_SIG: {
            // send dual press
            ButtonAB();
            status_ = Q_TRAN(&Buttons_wait);
            break;
        }
        default: {
            status_ = Q_SUPER(&Buttons_wait);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::Buttons} ###################################################*/
/*$define${AOs::Stage} #####################################################*/
/*${AOs::Stage} ............................................................*/
/*${AOs::Stage::SM} ........................................................*/
static QState Stage_initial(Stage * const me) {
    /*${AOs::Stage::SM::initial} */
    return Q_TRAN(&Stage_ReadyWaiting);
}
/*${AOs::Stage::SM::ReadyWaiting} ..........................................*/
static QState Stage_ReadyWaiting(Stage * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Stage::SM::ReadyWaiting} */
        case Q_ENTRY_SIG: {
            // set the indicator to both lights on
            RedOnGreenOn();
            // wait for button press
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Stage::SM::ReadyWaiting} */
        case Q_EXIT_SIG: {
            LightsOff();
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Stage::SM::ReadyWaiting::SINGLEPRESS_A} */
        case SINGLEPRESS_A_SIG: {
            /*${AOs::Stage::SM::ReadyWaiting::SINGLEPRESS_A::[Alreadyhome]} */
            if (digitalRead(OPTICAL_A)) {
                status_ = Q_TRAN(&Stage_ShortMove);
            }
            /*${AOs::Stage::SM::ReadyWaiting::SINGLEPRESS_A::[else]} */
            else {
                status_ = Q_TRAN(&Stage_HomeInit);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

// drive the stage to the home position, then flash the indicators together
// Stepper speed and direction set on entry
/*${AOs::Stage::SM::FindHome} ..............................................*/
static QState Stage_FindHome(Stage * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Stage::SM::FindHome} */
        case Q_ENTRY_SIG: {
            setDirectionHome();
            activateStepper();
            setStepperSeed(&me->super, BSP_TICKS_PER_SEC/100U);

            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Stage::SM::FindHome} */
        case Q_EXIT_SIG: {
            me->CurrentStep = 0;
            deactivateStepper();
            stopStepperSpeedTimer(&me->super);

            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Stage::SM::FindHome::OPTICALSTOP_A} */
        case OPTICALSTOP_A_SIG: {
            status_ = Q_TRAN(&Stage_AtHome);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Stage::SM::FindHome::HomeInit} ....................................*/
static QState Stage_HomeInit(Stage * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Stage::SM::FindHome::HomeInit::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            doStep();
            status_ = Q_TRAN(&Stage_HomeInit);
            break;
        }
        default: {
            status_ = Q_SUPER(&Stage_FindHome);
            break;
        }
    }
    return status_;
}
/*${AOs::Stage::SM::AtHome} ................................................*/
static QState Stage_AtHome(Stage * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Stage::SM::AtHome} */
        case Q_ENTRY_SIG: {
            RedFlashGreenFlashSync();

            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Stage::SM::AtHome} */
        case Q_EXIT_SIG: {
            LightsOff();
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Stage::SM::AtHome::SINGLEPRESS_A} */
        case SINGLEPRESS_A_SIG: {
            TotalCuts=TotalCuts1;
            cutsteparray=cutsteparray1;

            status_ = Q_TRAN(&Stage_CutSequence);
            break;
        }
        /*${AOs::Stage::SM::AtHome::SINGLEPRESS_B} */
        case SINGLEPRESS_B_SIG: {
            TotalCuts=TotalCuts2;
            cutsteparray=cutsteparray2;

            status_ = Q_TRAN(&Stage_CutSequence);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Stage::SM::CutSequence} ...........................................*/
static QState Stage_CutSequence(Stage * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Stage::SM::CutSequence} */
        case Q_ENTRY_SIG: {
            me->CurrentCut = 0;
            activateStepper();
            // Needs to be slower than usual if we're doing serial IO for debugging
            setStepperSeed(&me->super, BSP_TICKS_PER_SEC/200U);

            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Stage::SM::CutSequence} */
        case Q_EXIT_SIG: {
            deactivateStepper();
            stopStepperSpeedTimer(&me->super);

            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Stage::SM::CutSequence::OPTICALSTOP_A} */
        case OPTICALSTOP_A_SIG: {
            status_ = Q_TRAN(&Stage_Error);
            break;
        }
        /*${AOs::Stage::SM::CutSequence::OPTICALSTOP_B} */
        case OPTICALSTOP_B_SIG: {
            status_ = Q_TRAN(&Stage_Error);
            break;
        }
        /*${AOs::Stage::SM::CutSequence::SINGLEPRESS_A} */
        case SINGLEPRESS_A_SIG: {
            //RedFlashGreenOff();
            /*${AOs::Stage::SM::CutSequence::SINGLEPRESS_A::[checkdirection]} */
            if ((me->CurrentStep) > (cutsteparray[me->CurrentCut])) {
                setDirectionHome();
                RedFlashGreenOff();
                status_ = Q_TRAN(&Stage_SeekHome);
            }
            /*${AOs::Stage::SM::CutSequence::SINGLEPRESS_A::[else]} */
            else {
                setDirectionAway();
                RedOffGreenFlash();
                status_ = Q_TRAN(&Stage_SeekAway);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Stage::SM::CutSequence::SeekSuper} ................................*/
static QState Stage_SeekSuper(Stage * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Stage::SM::CutSequence::SeekSuper} */
        case Q_EXIT_SIG: {
            ++(me->CurrentCut);
            LightsOff();

            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Stage_CutSequence);
            break;
        }
    }
    return status_;
}
/*${AOs::Stage::SM::CutSequence::SeekSuper::SeekHome} ......................*/
static QState Stage_SeekHome(Stage * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Stage::SM::CutSequence::SeekSuper::SeekHome} */
        case Q_ENTRY_SIG: {
            setDirectionHome();
            BSP_Debug("Seek home");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Stage::SM::CutSequence::SeekSuper::SeekHome::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            doStep();
            --(me->CurrentStep);
            #ifdef SERIALDEBUG
            Serial.print(me->CurrentStep);
            Serial.print(" ");
            Serial.print(me->CurrentCut);
            Serial.print(" ");

            Serial.print(cutsteparray[me->CurrentCut]);
            Serial.println("");
            #endif
            /*${AOs::Stage::SM::CutSequence::SeekSuper::SeekHome::Q_TIMEOUT::[foundthecutposition]} */
            if (me->CurrentStep == cutsteparray[me->CurrentCut]) {
                #ifdef SERIALDEBUG
                Serial.println("Reached target");
                #endif
                /*${AOs::Stage::SM::CutSequence::SeekSuper::SeekHome::Q_TIMEOUT::[foundthecutposi~::[checkfinishedcuts]} */
                if (me->CurrentCut == (TotalCuts-1)) {
                    status_ = Q_TRAN(&Stage_Complete);
                }
                /*${AOs::Stage::SM::CutSequence::SeekSuper::SeekHome::Q_TIMEOUT::[foundthecutposi~::[else]} */
                else {
                    status_ = Q_TRAN(&Stage_CutSequence);
                }
            }
            /*${AOs::Stage::SM::CutSequence::SeekSuper::SeekHome::Q_TIMEOUT::[else]} */
            else {
                status_ = Q_TRAN(&Stage_SeekHome);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Stage_SeekSuper);
            break;
        }
    }
    return status_;
}
/*${AOs::Stage::SM::CutSequence::SeekSuper::SeekAway} ......................*/
static QState Stage_SeekAway(Stage * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Stage::SM::CutSequence::SeekSuper::SeekAway} */
        case Q_ENTRY_SIG: {
            BSP_Debug("Seek away");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Stage::SM::CutSequence::SeekSuper::SeekAway::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            doStep();
            ++(me->CurrentStep);
            #ifdef SERIALDEBUG
            Serial.print(me->CurrentStep);
            Serial.print(" ");
            Serial.print(me->CurrentCut);
            Serial.print(" ");

            Serial.print(cutsteparray[me->CurrentCut]);
            Serial.println("");
            #endif
            /*${AOs::Stage::SM::CutSequence::SeekSuper::SeekAway::Q_TIMEOUT::[foundcutposition]} */
            if (me->CurrentStep == cutsteparray[me->CurrentCut]) {
                #ifdef SERIALDEBUG
                Serial.println("Reached target");
                #endif
                /*${AOs::Stage::SM::CutSequence::SeekSuper::SeekAway::Q_TIMEOUT::[foundcutpositio~::[checkfinishedcuts]} */
                if (me->CurrentCut == (TotalCuts-1)) {
                    status_ = Q_TRAN(&Stage_Complete);
                }
                /*${AOs::Stage::SM::CutSequence::SeekSuper::SeekAway::Q_TIMEOUT::[foundcutpositio~::[else]} */
                else {
                    status_ = Q_TRAN(&Stage_CutSequence);
                }
            }
            /*${AOs::Stage::SM::CutSequence::SeekSuper::SeekAway::Q_TIMEOUT::[else]} */
            else {
                status_ = Q_TRAN(&Stage_SeekAway);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Stage_SeekSuper);
            break;
        }
    }
    return status_;
}
/*${AOs::Stage::SM::Error} .................................................*/
static QState Stage_Error(Stage * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Stage::SM::Error} */
        case Q_ENTRY_SIG: {
            RedFlashGreenFlashASync();
            BSP_Debug("Error");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Stage::SM::Complete} ..............................................*/
static QState Stage_Complete(Stage * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Stage::SM::Complete} */
        case Q_ENTRY_SIG: {
            RedOffGreenFlash();
            BSP_Debug("Complete");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Stage::SM::ClearHome} .............................................*/
static QState Stage_ClearHome(Stage * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Stage::SM::ClearHome} */
        case Q_ENTRY_SIG: {
            setDirectionAway();
            activateStepper();
            setStepperSeed(&me->super, BSP_TICKS_PER_SEC/100U);
            me->CurrentStep = 0;
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Stage::SM::ClearHome} */
        case Q_EXIT_SIG: {
            deactivateStepper();
            stopStepperSpeedTimer(&me->super);

            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Stage::SM::ClearHome::OPTICALSTOP_B} */
        case OPTICALSTOP_B_SIG: {
            status_ = Q_TRAN(&Stage_HomeInit);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Stage::SM::ClearHome::ShortMove} ..................................*/
static QState Stage_ShortMove(Stage * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Stage::SM::ClearHome::ShortMove::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            doStep();
            ++(me->CurrentStep);
            /*${AOs::Stage::SM::ClearHome::ShortMove::Q_TIMEOUT::[farenough]} */
            if (me->CurrentStep > 200) {
                status_ = Q_TRAN(&Stage_HomeInit);
            }
            /*${AOs::Stage::SM::ClearHome::ShortMove::Q_TIMEOUT::[else]} */
            else {
                status_ = Q_TRAN(&Stage_ShortMove);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Stage_ClearHome);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::Stage} #####################################################*/
//...
